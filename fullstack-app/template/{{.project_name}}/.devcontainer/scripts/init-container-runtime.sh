#!/bin/bash
# =============================================================================
# Dev Container Runtime Initializer
# =============================================================================
# This script runs on the HOST machine before the dev container starts.
# It ensures Docker or Podman is installed, running, and properly configured.
#
# It also generates docker-compose.override.yml with runtime-specific settings
# (e.g., userns_mode: keep-id for Podman) to avoid cross-runtime errors.
#
# Supports: macOS, Linux (including WSL2)
# =============================================================================

set -e

# Resolve paths relative to the script location
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
DEVCONTAINER_DIR="$(dirname "$SCRIPT_DIR")"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Track which runtime was selected (used by cleanup trap)
SELECTED_RUNTIME=""

# Detect OS
detect_os() {
    case "$(uname -s)" in
        Darwin*)  echo "macos" ;;
        Linux*)
            if grep -qEi "(Microsoft|WSL)" /proc/version 2>/dev/null; then
                echo "wsl"
            else
                echo "linux"
            fi
            ;;
        MINGW*|CYGWIN*|MSYS*) echo "windows" ;;
        *) echo "unknown" ;;
    esac
}

OS=$(detect_os)

# Logging functions
log_info() { echo -e "${BLUE}ℹ${NC} $1"; }
log_success() { echo -e "${GREEN}✓${NC} $1"; }
log_warn() { echo -e "${YELLOW}⚠${NC} $1"; }
log_error() { echo -e "${RED}✗${NC} $1"; }
log_step() { echo -e "${CYAN}▶${NC} ${BOLD}$1${NC}"; }

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# =============================================================================
# Compose Override Generation
# =============================================================================

generate_compose_override() {
    local runtime="$1"
    local override_file="$DEVCONTAINER_DIR/docker-compose.override.yml"

    if [ "$runtime" = "podman" ]; then
        cat > "$override_file" << 'YAML'
# Auto-generated by init-container-runtime.sh — do not edit
# Podman-specific settings (userns_mode is not supported by Docker)
services:
  dev:
    userns_mode: keep-id
YAML
        log_info "Generated compose override for Podman (userns_mode: keep-id)"
    else
        cat > "$override_file" << 'YAML'
# Auto-generated by init-container-runtime.sh — do not edit
# No runtime-specific overrides needed for Docker
services:
  dev: {}
YAML
    fi
}

# =============================================================================
# Prerequisite Checks
# =============================================================================

ensure_config_files_exist() {
    # Create host config files needed for bind mounts in devcontainer.json
    if [ ! -f "$HOME/.databrickscfg" ]; then
        touch "$HOME/.databrickscfg"
        log_info "Created empty ~/.databrickscfg"
    fi

    if [ ! -f "$HOME/.gitconfig" ]; then
        touch "$HOME/.gitconfig"
        log_info "Created empty ~/.gitconfig"
    fi
}

# =============================================================================
# Cleanup Trap — ensures required files exist even on script failure
# =============================================================================

cleanup() {
    local exit_code=$?
    # Always ensure the compose override exists (devcontainer.json references it)
    if [ ! -f "$DEVCONTAINER_DIR/docker-compose.override.yml" ]; then
        generate_compose_override "${SELECTED_RUNTIME:-docker}"
    fi
    # Always ensure bind-mount targets exist
    ensure_config_files_exist
    exit "$exit_code"
}
trap cleanup EXIT

# =============================================================================
# Docker Functions
# =============================================================================

check_docker_installed() {
    command_exists docker
}

check_docker_running() {
    docker info >/dev/null 2>&1
}

start_docker_macos() {
    log_step "Starting Docker Desktop..."

    if [ ! -d "/Applications/Docker.app" ]; then
        log_error "Docker Desktop is not installed at /Applications/Docker.app"
        return 1
    fi

    open -a Docker

    # Wait for Docker to become responsive
    local max_wait=60
    local elapsed=0
    echo -n "  Waiting for Docker to start"
    while [ $elapsed -lt $max_wait ]; do
        if docker info >/dev/null 2>&1; then
            echo ""
            log_success "Docker Desktop is running"
            return 0
        fi
        echo -n "."
        sleep 2
        elapsed=$((elapsed + 2))
    done

    echo ""
    log_error "Docker Desktop failed to start within ${max_wait}s"
    log_info "Please start Docker Desktop manually and try again"
    return 1
}

start_docker_linux() {
    log_step "Starting Docker service..."

    # Try systemctl first (most modern distros)
    if command_exists systemctl; then
        if sudo systemctl start docker 2>/dev/null; then
            sleep 2
            if check_docker_running; then
                log_success "Docker service started via systemctl"
                return 0
            fi
        fi
    fi

    # Fallback to service command
    if command_exists service; then
        if sudo service docker start 2>/dev/null; then
            sleep 2
            if check_docker_running; then
                log_success "Docker service started via service command"
                return 0
            fi
        fi
    fi

    log_error "Failed to start Docker service"
    log_info "Try manually: sudo systemctl start docker"
    return 1
}

start_docker_wsl() {
    log_step "Starting Docker in WSL..."

    # Check Docker Desktop WSL2 integration
    if [ -S "/var/run/docker.sock" ]; then
        if check_docker_running; then
            log_success "Docker Desktop WSL integration is active"
            return 0
        fi

        log_warn "Docker Desktop may not be running on Windows host"
        log_info "Please start Docker Desktop on Windows"

        # Try to launch Docker Desktop via PowerShell
        if command_exists powershell.exe; then
            powershell.exe -Command "Start-Process 'C:\Program Files\Docker\Docker\Docker Desktop.exe'" 2>/dev/null || true

            local max_wait=60
            local elapsed=0
            echo -n "  Waiting for Docker Desktop"
            while [ $elapsed -lt $max_wait ]; do
                if check_docker_running; then
                    echo ""
                    log_success "Docker Desktop is running"
                    return 0
                fi
                echo -n "."
                sleep 2
                elapsed=$((elapsed + 2))
            done
            echo ""
        fi
    fi

    # Fallback to native Docker in WSL
    start_docker_linux
}

install_docker_instructions() {
    log_error "Docker is not installed"
    echo ""
    case $OS in
        macos)
            log_info "Install Docker Desktop:"
            echo "  brew install --cask docker"
            echo "  # Or download from: https://www.docker.com/products/docker-desktop"
            ;;
        linux)
            log_info "Install Docker:"
            echo "  # Ubuntu/Debian:"
            echo "  curl -fsSL https://get.docker.com | sh"
            echo "  sudo usermod -aG docker \$USER"
            echo ""
            echo "  # Fedora:"
            echo "  sudo dnf install docker-ce docker-ce-cli containerd.io"
            ;;
        wsl)
            log_info "Install Docker Desktop for Windows with WSL2 backend:"
            echo "  https://www.docker.com/products/docker-desktop"
            echo "  Enable WSL2 integration in Docker Desktop settings"
            ;;
    esac
}

# =============================================================================
# Podman Functions
# =============================================================================

check_podman_installed() {
    command_exists podman
}

check_podman_running() {
    # podman info works on both macOS (via machine) and Linux (daemonless)
    podman info >/dev/null 2>&1
}

podman_machine_exists() {
    # Check if any Podman machine exists (macOS only)
    [ "$OS" = "macos" ] && podman machine list --noheading 2>/dev/null | grep -q .
}

start_podman_macos() {
    log_step "Starting Podman machine..."

    # Create machine if none exists
    if ! podman_machine_exists; then
        log_info "Creating Podman machine (4 CPUs, 4GB RAM, 60GB disk)..."
        if ! podman machine init --cpus 4 --memory 4096 --disk-size 60; then
            log_error "Failed to create Podman machine"
            return 1
        fi
    fi

    # Check if already running
    if check_podman_running; then
        log_success "Podman machine is already running"
        return 0
    fi

    # Start the machine
    if ! podman machine start; then
        log_error "Failed to start Podman machine"
        log_info "Try: podman machine stop && podman machine start"
        return 1
    fi

    # Wait for it to become responsive
    local max_wait=30
    local elapsed=0
    echo -n "  Waiting for Podman machine"
    while [ $elapsed -lt $max_wait ]; do
        if check_podman_running; then
            echo ""
            log_success "Podman machine is running"
            return 0
        fi
        echo -n "."
        sleep 2
        elapsed=$((elapsed + 2))
    done

    echo ""
    log_error "Podman machine failed to become responsive within ${max_wait}s"
    return 1
}

start_podman_linux() {
    # Podman on Linux is daemonless, but socket is needed for compose
    log_step "Configuring Podman..."

    if command_exists systemctl; then
        systemctl --user enable --now podman.socket 2>/dev/null || true
    fi

    if check_podman_running; then
        log_success "Podman is ready"
        return 0
    else
        log_error "Podman is not responding"
        log_info "Try: podman info"
        return 1
    fi
}

install_podman_instructions() {
    log_warn "Podman is not installed"
    echo ""
    case $OS in
        macos)
            log_info "Install Podman:"
            echo "  brew install podman"
            echo "  podman machine init"
            echo "  podman machine start"
            ;;
        linux)
            log_info "Install Podman:"
            echo "  # Ubuntu/Debian:"
            echo "  sudo apt install podman"
            echo ""
            echo "  # Fedora:"
            echo "  sudo dnf install podman"
            ;;
    esac
}

# =============================================================================
# VS Code / Cursor Configuration
# =============================================================================

configure_vscode_for_podman() {
    log_step "Configuring VS Code/Cursor for Podman..."

    local settings_updated=false

    # Find VS Code/Cursor settings locations
    local vscode_dirs=(
        "$HOME/.config/Code/User"
        "$HOME/Library/Application Support/Code/User"
        "$HOME/.config/Cursor/User"
        "$HOME/Library/Application Support/Cursor/User"
    )

    for dir in "${vscode_dirs[@]}"; do
        if [ -d "$dir" ]; then
            local settings_file="$dir/settings.json"

            # Create settings.json if it doesn't exist
            if [ ! -f "$settings_file" ]; then
                echo '{}' > "$settings_file"
            fi

            # Skip if already configured for Podman
            if grep -q '"dev.containers.dockerPath".*"podman"' "$settings_file" 2>/dev/null; then
                continue
            fi

            # Use Python to update JSON safely
            if command_exists python3; then
                python3 << EOF
import json

settings_file = "$settings_file"
try:
    with open(settings_file, 'r') as f:
        settings = json.load(f)
except (json.JSONDecodeError, FileNotFoundError):
    settings = {}

settings['dev.containers.dockerPath'] = 'podman'
settings['dev.containers.dockerComposePath'] = 'podman-compose'

with open(settings_file, 'w') as f:
    json.dump(settings, f, indent=2)
    f.write('\n')
EOF
                settings_updated=true
                log_info "Updated: $settings_file"
            fi
        fi
    done

    if [ "$settings_updated" = true ]; then
        log_success "VS Code/Cursor configured to use Podman"
    else
        log_info "No VS Code/Cursor settings found to update (or already configured)"
    fi
}

configure_podman_docker_socket() {
    log_step "Setting up Docker socket compatibility..."

    case $OS in
        macos)
            local podman_socket="$HOME/.local/share/containers/podman/machine/podman.sock"
            if [ -S "$podman_socket" ]; then
                log_success "Podman socket available at: $podman_socket"
                export DOCKER_HOST="unix://$podman_socket"
                log_info "DOCKER_HOST=$DOCKER_HOST"
            else
                log_warn "Podman socket not found at expected path"
                log_info "This is normal if the machine just started — it should resolve on next run"
            fi
            ;;
        linux)
            if command_exists systemctl; then
                systemctl --user enable --now podman.socket 2>/dev/null || true
                local socket_path="/run/user/$(id -u)/podman/podman.sock"
                if [ -S "$socket_path" ]; then
                    export DOCKER_HOST="unix://$socket_path"
                    log_success "Podman socket: $socket_path"
                fi
            fi
            ;;
    esac
}

# =============================================================================
# Main Logic
# =============================================================================

main() {
    echo ""
    echo -e "${BOLD}${CYAN}════════════════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${CYAN}  Dev Container Runtime Initializer${NC}"
    echo -e "${BOLD}${CYAN}════════════════════════════════════════════════════════════${NC}"
    echo ""
    log_info "Detected OS: ${BOLD}$OS${NC}"
    echo ""

    local runtime=""
    local runtime_ready=false

    # Step 1: Detect available container runtime
    log_step "Detecting container runtime..."

    local has_docker=false
    local has_podman=false
    local docker_running=false
    local podman_running=false

    if check_docker_installed; then
        has_docker=true
        log_info "Docker is installed"
        if check_docker_running; then
            docker_running=true
        fi
    fi

    if check_podman_installed; then
        has_podman=true
        log_info "Podman is installed"
        if check_podman_running; then
            podman_running=true
        fi
    fi

    # Choose runtime: prefer whichever is already running, then Docker, then Podman
    if [ "$docker_running" = true ]; then
        runtime="docker"
    elif [ "$podman_running" = true ]; then
        runtime="podman"
    elif [ "$has_docker" = true ]; then
        runtime="docker"
    elif [ "$has_podman" = true ]; then
        runtime="podman"
    fi

    if [ -z "$runtime" ]; then
        echo ""
        log_error "No container runtime found!"
        echo ""
        install_docker_instructions
        echo ""
        echo -e "  ${BOLD}OR${NC}"
        echo ""
        install_podman_instructions
        echo ""
        exit 1
    fi

    SELECTED_RUNTIME="$runtime"
    echo ""
    log_info "Using container runtime: ${BOLD}$runtime${NC}"
    echo ""

    # Step 2: Ensure runtime is running
    if [ "$runtime" = "docker" ]; then
        if check_docker_running; then
            log_success "Docker is already running"
            runtime_ready=true
        else
            case $OS in
                macos) start_docker_macos && runtime_ready=true ;;
                linux) start_docker_linux && runtime_ready=true ;;
                wsl)   start_docker_wsl && runtime_ready=true ;;
            esac
        fi
    elif [ "$runtime" = "podman" ]; then
        if check_podman_running; then
            log_success "Podman is already running"
            runtime_ready=true
        else
            case $OS in
                macos) start_podman_macos && runtime_ready=true ;;
                linux) start_podman_linux && runtime_ready=true ;;
            esac
        fi

        # Configure IDE and socket for Podman
        if [ "$runtime_ready" = true ]; then
            echo ""
            configure_vscode_for_podman
            configure_podman_docker_socket
        fi
    fi

    if [ "$runtime_ready" != true ]; then
        echo ""
        log_error "Failed to start container runtime"
        log_info "The compose override file and config files will still be created"
        exit 1
    fi

    # Step 3: Validate the runtime can actually build/run containers
    echo ""
    log_step "Validating runtime..."
    if [ "$runtime" = "docker" ]; then
        if docker info >/dev/null 2>&1; then
            log_success "Docker is responsive"
        else
            log_error "Docker started but is not responding"
            exit 1
        fi
    elif [ "$runtime" = "podman" ]; then
        if podman info >/dev/null 2>&1; then
            log_success "Podman is responsive"
        else
            log_error "Podman started but is not responding"
            exit 1
        fi
    fi

    # Step 4: Generate compose override for the detected runtime
    echo ""
    log_step "Generating compose override..."
    generate_compose_override "$runtime"

    # Step 5: Ensure config files exist for bind mounts
    log_step "Ensuring configuration files exist..."
    ensure_config_files_exist
    log_success "Configuration files ready"

    # Final status
    echo ""
    echo -e "${BOLD}${GREEN}════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}  Container runtime is ready!${NC}"
    echo -e "${GREEN}  Runtime: $runtime${NC}"
    echo -e "${BOLD}${GREEN}════════════════════════════════════════════════════════════${NC}"
    echo ""
}

# Run main
main "$@"
